/**
 * Entitas Generated Components and Extensions for {{ namespace }}
 *
 * do not edit this file
 */
[indent=4]
uses Bosco
uses Bosco.ECS

const POOL_SIZE : int = {{ alloc.components }}

/**
* Component extensions
*/
const components: array of string = {
{% for component in components %}    "{{ component.key }}Component",
{% endfor %}    "ComponentsCount"
}

enum Component
{% for component in components %}    {{ component.key }}
{% endfor %}    ComponentsCount


{% for component in components %}
class {{ component.key }}Component : DarkMatter implements IComponent 
{% if component.value == false %}    active : bool = true
{% else %}{% for field in component.value %}    {{ field | property }} : {{ field | fieldType }} 
{% endfor %}{% endif %}{% endfor %}

namespace Bosco.ECS

    /**
    * Matcher extensions
    */
    class Matching : DarkMatter
{% for component in components %}
        /** @type {entitas.Matching} */
        _match{{ component.key }} : static IMatcher

        /** @type {entitas.Matcher} */
        prop static {{ component.key }} : IMatcher 
            get
                if _match{{ component.key }} == null
                    var match{{ component.key }} = Matcher.AllOf({Component.{{ component.key }}})
                return _match{{ component.key }}
{% endfor %}

    /**
    * World extensions
    */
    class World : WorldBase
        componentsEnum : static array of string
        totalComponents : static int = 0
        instance : static World 

        construct(componentsEnum : array of string, startCreationIndex : int=0)
            super(componentsEnum, startCreationIndex)

{% for entity in entities %}{% assign params = components[entity.key] %}{% if params.value == false %}
        /** @type {entitas.Match} */
        prop {{ entity.key | camel }}Entity : Entity
            get
                return getGroup(Matching.{{ entity.key }}).getSingleEntity()

        /** @type {boolean} */
        prop is{{ entity.key }} : bool
            get
                return {{ entity.key | camel }}Entity != null

            set
                var entity = {{ entity.key | camel }}Entity
                if value != (entity != null)
                    if value
                        createEntity("{{ entity.key }}").is{{ entity.key }} = true
                    else
                        destroyEntity(entity)
{% else %}
        /** @type {entitas.Entity} */
        prop {{ entity.key | camel }}Entity : Entity
            get
                return getGroup(Matching.{{ entity.key }}).getSingleEntity()

        /** @type {{{ namespace }}.{{ entity.key }}Component} */
        prop {{ entity.key | camel }} : {{ entity.key }}Component
            get
                return {{ entity.key | camel }}Entity.{{ entity.key | camel }}

        /** @type {boolean} */
        prop has{{ entity.key }} : bool
            get
                return {{ entity.key | camel }}Entity != null

        /**{% for field in params %}
         * @param {{ field | property }} {{ field | fieldType }}{% endfor %}
         * @return entitas.Entity
         */
        def set{{ entity.key }}({{ params }}) : Entity
            if has{{ entity.key }}
                raise new EcsException.SingleEntity("Matching {{ entity.key }}")

            var entity = createEntity("{{ entity.key }}")
            entity.add{{ entity.key }}({{ params | paramsonly }})
            return entity

        /**{% for field in params %}
         * @param {{ field | property }} {{ field | fieldType }}{% endfor %}
         * @return entitas.Entity
         */
        def replace{{ entity.key }}({{ params }}) : Entity
            var entity = {{ entity.key | camel }}Entity
            if entity == null
                entity = set{{ entity.key }}({{ params | paramsonly }})
            else
                entity.replace{{ entity.key }}({{ params | paramsonly }})
            return entity

        /**
         * @returns {entitas.Entity}
         */
        def remove{{ entity.key }}()
            destroyEntity({{ entity.key | camel }}Entity)
{% endif %}{% endfor %}


    /**
    * Entity extensions
    */
    class Entity : EntityBase

        construct(componentsEnum : array of string, totalComponents : int=32)
            super(componentsEnum, totalComponents)
            /* Preallocate component pools*/
{% for component in components %}{% if component.value == false %}
            _{{ component.key | camel }}Component = new {{ component.key }}Component()
{% else %}            _{{ component.key | camel }}ComponentPool = new GLib.Queue of {{ component.key }}Component
            for var i=1 to POOL_SIZE
                _{{ component.key | camel }}ComponentPool.push_head(new {{ component.key }}Component())
{% endif %}{% endfor %}
{% for component in components %}
        /** Entity: {{ component.key }} methods*/
{% if component.value == false %}
        /** @type boolean */
        prop is{{ component.key }} : bool
            get
                return hasComponent(Component.{{ component.key }})
            set
                if value
                    addComponent(Component.{{ component.key }}, _{{ component.key | camel }}Component)
                else
                    removeComponent(Component.{{ component.key }})
                
        /**
         * @param value boolean
         * @return entitas.Entity
         */
        def set{{ component.key }}(value : bool) : Entity
            is{{ component.key }} = value
            return this

{% else %}
        /** @type {{ component.key }} */
        prop {{ component.key | camel }} : {{ component.key }}Component
            get
                return ({{ component.key }}Component)getComponent(Component.{{ component.key }})

        /** @type boolean */
        prop has{{ component.key }} : bool
            get
                return hasComponent(Component.{{ component.key }})
 
        def clear{{ component.key }}ComponentPool()
            _{{ component.key | camel }}ComponentPool.clear()

        /**{% for field in component.value %}
         * @param {{ field | property }} {{ field | fieldType }}{% endfor %}
         * @return entitas.Entity
         */
        def add{{ component.key }}({{ component.value }}) : Entity
            var c = _{{ component.key | camel }}ComponentPool.length > 0 ? _{{ component.key | camel }}ComponentPool.pop_head() : new {{ component.key }}Component()
            {% for field in component.value %}c.{{ field | property }} = {{ field | property | camel }}
            {% endfor %}addComponent(Component.{{ component.key }}, c)
            return this

        /**{% for field in component.value %}
         * @param {{ field | property }} {{ field | fieldType }}{% endfor %}
         * @return entitas.Entity
         */
        def replace{{ component.key }}({{ component.value }}) : Entity
            var previousComponent = has{{ component.key }} ? this.{{ component.key | camel }} : null
            var c = _{{ component.key | camel }}ComponentPool.length>0? _{{ component.key | camel }}ComponentPool.pop_head() : new {{ component.key }}Component()
            {% for field in component.value %}c.{{ field | property }} = {{ field | property | camel }}
            {% endfor %}replaceComponent(Component.{{ component.key }}, c) 
            if previousComponent != null
                _{{ component.key | camel }}ComponentPool.push_head(previousComponent)
            return this

        /**
         * @returns entitas.Entity
         */
        def remove{{ component.key }}() : Entity
            var c = {{ component.key | camel }}
            removeComponent(Component.{{ component.key }}) 
            _{{ component.key | camel }}ComponentPool.push_head(c)
            return this

{% endif %}{% endfor %}
{% for component in components %}{% if component.value == false %}
        /** @type {{ component.key }} */
        _{{ component.key | camel }}Component : {{ component.key }}Component
{% else %}        /** @type entitas.utils.GLib.Queue<{{ component.key }}> */
        _{{ component.key | camel }}ComponentPool : GLib.Queue of {{ component.key }}Component
{% endif %}{% endfor %}
